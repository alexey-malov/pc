# Атомарные операции и lock-free структуры данных

- [Атомарные операции и lock-free структуры данных](#атомарные-операции-и-lock-free-структуры-данных)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание 1 — TicketOffice — 30 баллов](#задание-1--ticketoffice--30-баллов)
      - [Бонус за сравнение производительности с lock-based версией класса — 10 баллов](#бонус-за-сравнение-производительности-с-lock-based-версией-класса--10-баллов)
    - [Задание 2 — AtomicMax — 20 баллов](#задание-2--atomicmax--20-баллов)
      - [Бонус за сравнение производительности с lock-based версией класса — 10 баллов](#бонус-за-сравнение-производительности-с-lock-based-версией-класса--10-баллов-1)
    - [Задание 3 — lock-free thread pool — 70 баллов](#задание-3--lock-free-thread-pool--70-баллов)
    - [Задание 4 — StopToken и StopSource — 30 баллов](#задание-4--stoptoken-и-stopsource--30-баллов)
    - [Задание 5 — изучение внутреннего конкурентной структуры данных — до 120 баллов](#задание-5--изучение-внутреннего-конкурентной-структуры-данных--до-120-баллов)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее 80 баллов.
- На оценку "хорошо" нужно набрать не менее 120 баллов.
- Для получения оценки "отлично" нужно набрать не менее 250 баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и используемых библиотек
и не игнорируйте ошибки.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание 1 — TicketOffice — 30 баллов

Реализуйте класс `TicketOffice`, выполняющий продажу билетов в lock-free стиле.
Метод `SellTickets` выполняет продажу билетов по следующим правилам:

- Нельзя продать больше билетов, чем имеется в наличии.
- Параметр ticketsToBuy должен быть положительным.

Прототип класса TicketOffice дан ниже.

```cpp
class TicketOffice
{
public:
    explicit TicketOffice(int numTickets);

    TicketOffice(const TicketOffice&) = delete;
    TicketOffice& operator=(const TicketOffice&) = delete;

    /**
     * Выполняет продажу билета.
     * Возвращает количество фактически проданных билетов.
     * Если ticketsToBuy <= 0, выбрасывается исключение std::invalid_argument
     */
    int SellTickets(int ticketsToBuy);

    int GetTicketsLeft() const noexcept;

private:
    // Количество билетов должно быть атомарным
    std::atomic<int> m_numTickets;
};
```

Расставьте правильным образом порядок доступа к атомарным переменным.

Для проверки работы класса в многопоточном режиме напишите юнит-тесты.

#### Бонус за сравнение производительности с lock-based версией класса — 10 баллов

Проведите измерения времени работы программы при количестве потоков, изменяющемся от 1 до 30
и сравните его с версией класса `TicketOfficeWithLock`, использующей мьютекс для синхронизации.
Сделайте выводы.

### Задание 2 — AtomicMax — 20 баллов

Разработайте шаблонный класс AtomicMax, позволяющий атомарно обновлять максимальное значение.

```cpp
template <typename T>
class AtomicMax
{
public:
    explicit AtomicMax(T value);

    void Update(T newValue) noexcept;

    T GetValue() const noexcept;

private:
    std::atomic<T> m_value;
};
```

Расставьте правильным образом порядок доступа к атомарным переменным.

Для проверки работы класса в многопоточном режиме напишите юнит-тесты.

#### Бонус за сравнение производительности с lock-based версией класса — 10 баллов

Проведите измерения времени работы программы при количестве потоков, изменяющемся от 1 до 30
и сравните его с версией класса `AtomicMaxWithLock`, использующей мьютекс для синхронизации.
Сделайте выводы.

### Задание 3 — lock-free thread pool — 70 баллов

Разработайте класс ThreadPool, используя одну из имеющихся lock-free реализаций очередей.
Можно взять из Boost.LockFree (<https://boost.org>) или libcds (<https://github.com/khizmax/libcds>).

Напишите тесты для этого класса.

Сравните производительность (время выполнения N операций в lock-free и lock-based) реализаций Thread Pool,
а также с boost::asio::thread_pool.
Постройте график зависимости времени выполнения N операций от количества потоков (от 1 до 2 * количество процессоров).

### Задание 4 — StopToken и StopSource — 30 баллов

Разработайте классы `StopToken` и `StopSource`, являющиеся упрощёнными версиями классов `std::stop_token` и `std::stop_source`.

`StopSource` должен предоставлять методы:

- `RequestStop` для запроса остановки.
- `GetToken` для получения `StopToken`.

`StopToken` должен предоставлять методы:

- `StopRequested` для проверки того, была ли запрошена остановка.

### Задание 5 — изучение внутреннего конкурентной структуры данных — до 120 баллов

Согласуйте с преподавателем тему индивидуального задания по изучению реализации одной из конкурентных
структур данных. В процессе выполнения задания вам надо будет ознакомиться с исходным кодом реализации
и подготовить небольшой доклад с описанием внутреннего устройства этой структуры данных и используемых алгоритмов.
