# Корутины

- [Корутины](#корутины)
  - [Знакомство с корутинами C++ 20](#знакомство-с-корутинами-c-20)
    - [Что такое корутины (сопрограммы)](#что-такое-корутины-сопрограммы)
    - [Типы корутин](#типы-корутин)
    - [Преимущества использования корутин](#преимущества-использования-корутин)
    - [Ключевые элементы корутин в C++20](#ключевые-элементы-корутин-в-c20)
    - [Архитектура и реализация](#архитектура-и-реализация)
    - [Примеры использования](#примеры-использования)
    - [Особенности и предостережения](#особенности-и-предостережения)
    - [Практические рекомендации](#практические-рекомендации)
    - [Итоги](#итоги)

## Знакомство с корутинами C++ 20

Это краткое описание лекции. [Смотреть полное видео на Youtube](https://youtu.be/1hw8j6FhZiA).

### Что такое корутины (сопрограммы)

- Корутины — это функции, которые можно приостанавливать и возобновлять в процессе выполнения.
- В отличие от обычных функций, они не обязательно завершаются за один вызов.
- Основная цель — упростить написание кода, особенно для асинхронных или ленивых вычислений.
- Примеры из других языков: `async/await` в JavaScript и C#.

---

### Типы корутин

- **Stackless (без собственного стека)**
  - Встроены в стандарт C++ с версии C++20.
  - Выполняются в контексте вызывающей функции, без отдельного стека.
- **Stackful (с собственным стеком)**
  - Поддерживаются библиотеками (например, Boost.Coroutine).
  - Более гибкие, но требуют ручного управления стеком.

---

### Преимущества использования корутин

- Упрощение асинхронного и ленивого кода: избавляют от вложенных колбэков и `std::promise`.
- Позволяют писать асинхронный код в синхронном стиле, улучшая читаемость.
- Эффективны при работе с I/O и другими сценариями, где программа часто «ждёт».

---

### Ключевые элементы корутин в C++20

- `co_await` — приостанавливает выполнение, пока awaitable-объект не будет готов.
- `co_yield` — приостанавливает выполнение и возвращает значение, как в генераторах.
- `co_return` — завершает выполнение и возвращает результат.

---

### Архитектура и реализация

- Компилятор преобразует функции, содержащие ключевые слова `co_await`, `co_yield` или `co_return`, в корутины.
- Для каждой корутины создаётся `promise_type`, определяющий её поведение.
- Интерфейс `std::coroutine_handle<>` позволяет управлять жизненным циклом корутины
  (вызов `resume()`, `destroy()`, проверка `done()` и др.).
- Используется `std::coroutine_traits<>` для связывания возвращаемого типа и `promise_type`.

---

### Примеры использования

- **Генераторы**:
  - Например, `std::generator` (доступен в C++23) позволяет итерироваться по ленивым последовательностям.
- **Асинхронные задачи:**
  - Работа с I/O (чтение файлов, сетевые запросы) через `co_await` и awaitable-объекты.

---

### Особенности и предостережения

- Корутины сохраняют локальные переменные между приостановками.
- **Stackless-корутины** эффективны по памяти, но не поддерживают произвольные переключения контекста, как stackful.
- Всегда проверяйте, валиден ли `coroutine_handle`, прежде чем вызывать `resume()` или другие методы.
- Нужно явно управлять временем жизни и завершением корутин.

---

### Практические рекомендации

- Используйте корутины в задачах, где есть много операций ожидания (сетевые задержки, I/O, таймеры).
- Обрабатывайте исключения внутри корутин с помощью `try/catch`.
- Освобождайте ресурсы корректно: завершённые корутины должны быть уничтожены через `destroy()`.

---

### Итоги

Корутины в C++20 — это мощный инструмент, который позволяет писать понятный и эффективный асинхронный код.
Они абстрагируют сложность управления состоянием и позволяют избавиться от callback hell.
Однако использование корутин требует понимания их механизма, включая `promise_type`,
`coroutine_handle` и поведение компилятора.