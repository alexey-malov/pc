# Вопросы к экзамену/зачёту

## Lock-free

- Какими свойствами должна обладать структура данных или алгоритм,
  чтобы считаться lock-free?
- Какие гарантии исполнения могут предоставлять неблокирующие структуры данных и алгоритмы?
- 

## Корутины

- Когда и как создаётся возвращаемый из корутины объект?
- Что должно произойти внутри корутины, чтобы у промиса вызвался final_suspend.- Чем отличается coroutine_handle<> от coroutine_handle<promise>?
- Что раньше создаётся promise_type или возвращаемое значение?
- Что насчёт копирования и присваивания возвращаемого типа корутины?
- Чем отличается корутина от обычной функции с точки зрения вызывающего её кода?
- Можно ли разместить определение promise_type вне return object? Если да, то как, если нет то почему?
- Какой awaiter должен возвращать yield_value: suspend_always или suspend_never, почему? Может ли возвращать другой тип awaiter.
- За счёт чего корутина-генератор возобновляет выполнение после вызова co_yield?
- Что нужно сделать, чтобы возобновить работу приостановленной корутины?
- Как сделать генератор, который бы не хранил копию yielded значения?
- Какие типы возвращаемых значений могут быть у метода awaiter::await_suspend.
  Что они означают?
- Что нужно сделать у возвращаемого значения корутины, чтобы его можно было
  ожидать с помощью операции co_await? Как сделать так, чтобы особые методы не были видны клиентам напрямую?
- Какую роль в работе корутины играет ReturnObject::promise_type?
- Как сохранить исключение, выброшенное в теле корутины, чтобы потом можно было узнать о его наличии и выбросить?
- Что такое awaiter? Что нужно сделать, чтобы тип мог быть awaiter-ом?
- Что нужно сделать, чтобы co_await не приостанавливал свое выполнение на awaiter-а, а сразу продолжал ее работу?
- Что возвращает оператор co_await?
- Какие из методов awaiter-а должны быть noexcept и почему?
