# Вопросы к экзамену/зачёту

- [Вопросы к экзамену/зачёту](#вопросы-к-экзаменузачёту)
  - [Конкурентность и параллелизм](#конкурентность-и-параллелизм)
    - [Общие сведения о конкурентности и параллелизме](#общие-сведения-о-конкурентности-и-параллелизме)
    - [Подходы к конкурентности](#подходы-к-конкурентности)
    - [Конкурентность для разделения ответственности](#конкурентность-для-разделения-ответственности)
    - [Конкурентность для повышения производительности](#конкурентность-для-повышения-производительности)
    - [Чрезвычайная параллельность](#чрезвычайная-параллельность)
    - [Когда использовать, а когда не использовать конкурентность](#когда-использовать-а-когда-не-использовать-конкурентность)
  - [Закон Амдала](#закон-амдала)
  - [Запуск потока](#запуск-потока)
    - [Запуск потока средствами ОС](#запуск-потока-средствами-ос)
    - [Запуск потока средствами стандартной библиотеки](#запуск-потока-средствами-стандартной-библиотеки)
    - [Функция потока](#функция-потока)
    - [Передача параметров потоку связанные с этим проблемы](#передача-параметров-потоку-связанные-с-этим-проблемы)
  - [Многопоточная работа с общими данными](#многопоточная-работа-с-общими-данными)
  - [Взаимная блокировка](#взаимная-блокировка)
  - [Сихронизация операций между потоками](#сихронизация-операций-между-потоками)
  - [Lock-free](#lock-free)
  - [Корутины](#корутины)

## Конкурентность и параллелизм

### Общие сведения о конкурентности и параллелизме

- Что такое конкурентность в компьютерных системах?
  Приведите примеры её применения из повседневной жизни или программного обеспечения.
- В чём заключается ключевое отличие параллелизма от конкурентности?
  Объясните, как они различаются по целям и подходам.
- Перечислите основные предпосылки использования конкурентности в программировании.
- Какие аппаратные требования необходимы для реализации параллелизма?
  Почему конкурентность может обходиться без них?
- Объясните, как конкурентность улучшает отзывчивость пользовательского интерфейса.
- Какие цели преследует параллелизм?
- В чём состоит идея "переключения между задачами" в конкурентности?
  Как это отличается от "одновременного выполнения" в параллелизме?
- Приведите пример ситуации, где конкурентность будет более эффективной, чем параллелизм. Почему?
- Как конкурентность и параллелизм взаимодействуют в приложениях, например в играх.
- Почему для высоконагруженных серверных систем важна реализация конкурентности?
  Как это влияет на производительность?

### Подходы к конкурентности

- Проиллюстрируйте разницу между многопроцессностью и многопоточностью на примере организации совместной работы в реальной жизни?
  Какие преимущества и недостатки каждого подхода можно выделить?
- В чём заключаются основные отличия многопроцессного подхода от многопоточного?
  Приведите примеры сценариев, где каждый из подходов будет предпочтительным.
- Перечислите механизмы межпроцессного взаимодействия (IPC).
  Какие из них являются наиболее эффективными для передачи больших объёмов данных?
- Почему управление потоками требует меньше ресурсов по сравнению с процессами?
  Какие риски возникают при использовании общей памяти в многопоточном приложении?
- Что такое SIMD-инструкции? Как они используются для повышения производительности вычислений?
  Приведите примеры реализации SIMD на различных архитектурах процессоров.
  Назовите особенности этих реализаций.
- В чём заключается автоматическая векторизация компилятором,
  как она отличается от использования инструкций intrinsic или ассемблера?
  Когда какой способ векторизации использовать?
- Какова архитектура GPU, и в чём её отличие от архитектуры CPU?
  Почему GPU подходит для задач с массовым параллелизмом?
- Объясните концепцию SIMT (Single Instruction – Multiple Threads) в контексте работы GPU.
  Как это влияет на выполнение параллельных вычислений?
- В каких сценариях целесообразно использовать комбинацию многопроцессного и многопоточного подходов?
  Приведите примеры из реальных систем.
- Сравните подходы к конкурентности: многопроцессность, многопоточность, векторизация и вычисления на GPU.
  В каких задачах каждый из них будет наиболее эффективен?
  Приведите примеры использования для каждого подхода.

### Конкурентность для разделения ответственности

- Как конкурентность помогает в разделении ответственности между разнородными задачами в программе?
  Приведите пример, где это особенно важно.
- Почему UI-поток должен быть отделен от фоновых операций?
  Как это обеспечивает иллюзию отзывчивости интерфейса?
- Объясните, почему количество потоков в конкурентном приложении может превышать количество ядер процессора.
  Как операционная система управляет такими потоками?
- Как разделение кода на связанный и несвязанный влияет на структуру программы?
  В чем преимущества такого подхода?
- Почему в примере многопоточного видеоплеера используется отдельный поток для декодирования видео и аудио?
  Как это улучшает производительность?
- Как потоки, выполняющие ввод-вывод (например, чтение с диска или сети), вносят вклад в общую эффективность приложения?
  Почему их можно считать "простаивающими"?
- Как использование конкурентности упрощает ручное переключение задач в программе?
  Приведите сценарий, где это особенно актуально.
- Почему в многопоточном видеоплеере потоки могут работать даже на однопроцессорном компьютере?
  Как это связано с работой планировщика ОС?
- Как разделение ответственности между потоками влияет на надежность и поддержку программы?
  Приведите пример, где это проявляется.
- Объясните, как конкурентность позволяет одновременно обрабатывать ввод пользователя,
  декодировать медиаданные и обновлять интерфейс в видеоплеере. Почему такой подход эффективен?

### Конкурентность для повышения производительности

- Как закон Мура связан с переходом от повышения тактовой частоты к параллельным вычислениям?
  Почему это важно для программистов?
- Почему стоимость разработки чипов (по закону Рока) стала критическим фактором в развитии процессоров?
  Как это повлияло на подходы к повышению производительности?
- Объясните, почему современные процессоры перестали увеличивать тактовую частоту и начали использовать многоядерные архитектуры.
  Как это связано с физическими ограничениями?
  Как физический предел роста количества транзисторов влияет на дальнейшее развитие производительности процессоров?
  Почему теперь фокус на параллельных вычислениях?
- Почему однопоточная программа не может воспользоваться преимуществами многоядерных процессоров?
  Приведите пример, где это приведёт к снижению производительности.
- Почему программное обеспечение должно быть адаптировано для работы с многоядерными системами?
  Какие последствия возникают, если это игнорировать?
- Как закон Мура и физические ограничения (например, размеры атома) повлияли на развитие архитектуры процессоров?
  Почему параллелизм стал ключевым направлением в последнее время?
- Объясните, как использование конкурентности позволяет приложениям эффективно использовать
  ресурсы современных многопроцессорных систем.
  Приведите пример сценария, где это критично.
- Почему GPU и мобильные устройства требуют от программ поддержки параллелизма?
  Как это связано с их архитектурными особенностями?
- Как современные системы (домашние компьютеры, мобильные устройства) демонстрируют необходимость параллельных вычислений?
  Почему однопоточная модель больше не подходит?

### Чрезвычайная параллельность

- Объясните, какие алгоритмы или задачи называются "чрезвычайно параллельными"
  и почему они отличаются от других по характеру взаимодействия между параллельными потоками?
  Приведите примеры из слайда.
- Почему задачи, такие как рендеринг 3D-графики или майнинг криптовалюты, являются особенно подходящими для параллельного исполнения?
  Какие архитектурные особенности оборудования способствуют этому?
- Как факторы производительности, такие как скорость диска или процессора, влияют на эффективность параллелизации задач,
  например, при отдаче статических файлов с веб-сервера? Объясните на примере.
- Опишите, как можно распараллелить вычисления в системе моделирования частиц
  (например, с использованием физических законов взаимодействия).
  Как такое разделение обеспечивает прирост производительности?

### Когда использовать, а когда не использовать конкурентность

- Перечислите основные причины, по которым использование конкурентности может быть нецелесообразным.
  Объясните, как сложность кода и затраты на отладку влияют на это решение.
- Почему создание большого количества потоков в 32-битных системах ограничено? Какие ресурсы исчерпываются в этом случае?
- Как накладные расходы на создание потоков могут превысить выигрыш в производительности?
  В каких сценариях это особенно актуально?
  Объясните, как переключение контекста между потоками влияет на производительность системы.
- Почему для обслуживания большого количества соединений в веб-сервере не подходит подход "один поток на соединение"?
  Какие есть альтернативы этому подходу?
- В чём преимущество пула потоков перед созданием отдельного потока для каждой задачи?
- Как асинхронный ввод-вывод уменьшает накладные расходы на переключение контекста?
- Объясните, как это реализуется в многопоточных приложениях.
- Почему в 64-битных системах ограничений на количество потоков меньше, чем в 32-битных?
  Какие ресурсы всё равно остаются ограничивающими?
- В чём разница между кооперативной многозадачностью и классическим многопоточным подходом?
  Как это влияет на производительность веб-сервера при обработке тысяч соединений?

## Закон Амдала

- Объясните суть закона Амдала и его формулу. Как она учитывает параллельную и последовательную части программы?
  Напишите формулу.
- Как максимальное ускорение программы ограничивается долями, которые нельзя распараллелить?
  Приведите примеры.
- Рассчитайте максимальное ускорение программы, если 20% времени занимает последовательная часть.
- Почему добавление большого количества процессоров не всегда приводит к линейному ускорению? С чем это связано?
- Как изменится формула Амдала, если учесть накладные расходы на синхронизацию и координацию между потоками?
  Приведите модифицированную формулу.
- Решите задачи на использование закона Амдала, предложенные преподавателем.

## Запуск потока

### Запуск потока средствами ОС

- Что происходит при запуске программы на C++ с точки зрения потоков?
- Почему для создания потока требуется обращение к операционной системе?
- Перечислите аргументы функции pthread_create и кратко опишите их назначение.
- Какой тип данных возвращает функция pthread_create и что означает её возвращаемое значение?
- Как передать данные в поток при использовании pthread_create?
- Как получить результат работы потока, созданного через pthread_create?
- Какие параметры можно задать при создании потока через CreateThread в Windows?
- Почему использование CreateThread в C/C++ программах может быть проблематичным?
- Для чего в Windows используются функции _beginthreadex и _endthreadex?
- В каких случаях предпочтительно использовать функции ОС для создания потока, а не std::thread?

### Запуск потока средствами стандартной библиотеки

- Для чего используется класс `std::thread` в C++ и с какой версии C++ он доступен?
- Что произойдет, если объект `std::thread` будет уничтожен без вызова `join()` или `detach()`?
- Объясните разницу между методами `join()` и `detach()` у std::thread.
  В каких случаях предпочтительно использовать каждый из них?
- Какие последствия могут возникнуть при использовании detach(), если поток выполняет важную или долгую задачу?
- Что произойдет при завершении функции `main`, если в программе был создан поток,
  вызван detach(), но сам поток не завершил выполнение?
- Чем std::jthread отличается от std::thread в контексте управления временем жизни потока?
- Что произойдёт при разрушении объекта std::jthread, если поток всё ещё выполняется?
- Можно ли вызывать методы join() и detach() у std::jthread? Как это влияет на его деструктор?
- Что означает, что поток joinable, и как std::jthread это учитывает в своём деструкторе?
- Почему std::jthread считается более безопасной альтернативой std::thread?
- Как узнать аппаратно доступное программе количество потоков?
- Как упорядочить операции ввода-вывода, происходящие в нескольких thread-ах одновременно.

### Функция потока

- Какие типы callable-объектов можно использовать в качестве функции потока при создании std::jthread?
- Что произойдёт с переданным в поток объектом, если он передаётся без std::move()?
- Почему в примере с MoveOnlyTask необходимо использовать std::move() при передаче объекта в поток?
  Что произойдёт с переменной task после этого?
- Чем отличается передача в поток копируемого объекта от передача перемещаемого? Объясните на примере std::unique_ptr.
- Как работают лямбда-выражения в качестве функций потока? Как осуществляется захват переменных и передача в поток?
- Объясните различия между `std::this_thread::get_id()` и методом `get_id()` объекта `std::thread`.
- Как можно использовать `std::thread::id` для идентификации потоков в многопоточной программе?
- Какие операции разрешены с `std::thread::id` , и почему его использование после завершения потока считается недопустимым?

### Передача параметров потоку связанные с этим проблемы

- В чём опасность передачи локальных переменных по ссылке в функцию потока?
  Объясните, почему в примере с `char buffer[]` из лекции возникает неопределённое поведение (UB) и как его можно устранить.
- Какие механизмы стандартной библиотеки C++ позволяют безопасно передавать параметры по ссылке в функцию потока?
  Приведите пример использования `std::ref` или `std::cref` из слайдов.  
- Почему при передаче строкового литерала `"Hello"` в функцию потока не возникает UB, даже если поток запущен с `detach`?
- Какой жизненный цикл аргументов, переданных в конструктор `std::thread` или `std::jthread`?
  Объясните, почему объект `std::thread` хранит аргументы конструктора, а не аргументы самой функции потока.  
- Объясните, почему передача C-массива в функцию потока через `std::thread` может привести к UB.
  Какие шаги необходимо предпринять, чтобы избежать работы с висячими указателями в многопоточных программах?

## Многопоточная работа с общими данными

- Гонки данных и конфликтующие вычисления:
  - Что такое состояние гонки (data race) и конфликтующие вычисления?
  - В каких случаях согласно модели памяти C++ возникает гонка данных?
  - Приведите пример кода, демонстрирующий гонку данных.
- Отношения порядка в многопоточности:
  - Что означают отношения happens-before, sequenced-before и synchronizes-with?
  - В каких ситуациях эти отношения возникают?
  - Почему понимание этих отношений важно при написании многопоточных программ?
  - Приведите примеры кода, иллюстрирующие их использование.
  - Почему после вызова метода `join()` можно безопасно обращаться к данным, модифицированным в функции потока?
- Использование мьютексов:
  - Что такое мьютекс и какова его роль в синхронизации?
  - Каким образом мьютекс помогает предотвратить гонку данных?
  - Чем отличаются `std::mutex` и `std::shared_mutex`?
  - В каких ситуациях следует использовать shared_mutex вместо обычного mutex?
- Гонка на уровне API:
  - Что такое API Race и в чём его отличие от гонки данных?
  - В каких ситуациях может возникнуть API Race?
  - Приведите примеры кода, демонстрирующие API Race.

## Взаимная блокировка

- Что такое взаимная блокировка (deadlock) и чем она отличается от состояния гонки (race condition)?
- Приведите пример из практики, где взаимная блокировка привела к серьёзным последствиям.
  Почему важно учитывать такие риски в критически важных системах?
- Как может возникнуть deadlock при использовании мьютексов? Приведите пример, связанный с присваиванием данных между потоками.
- Объясните, как вложенные блокировки могут привести к взаимной блокировке. Какие ситуации особенно опасны?
- В чём суть проблемы "обедающих философов"? Как она моделирует взаимную блокировку в многопоточной среде?
- Опишите основные стратегии предотвращения deadlock.
- Как `std::lock` и `std::scoped_lock` помогают предотвратить взаимные блокировки при захвате нескольких мьютексов?
- Что такое иерархические мьютексы и как они работают для предотвращения deadlock?
- Почему не рекомендуется вызывать внешний код (например, обработчики или функции обратного вызова) находясь под мьютексом?
- Какие проблемы могут возникнуть при использовании `fork()` в многопоточной программе? Как они связаны с блокировками?

## Сихронизация операций между потоками

- В чём заключается основная проблема использования busy-wait при ожидании события в многопоточном приложении?
- Чем отличается поведение `condition_variable` от `sleep`-ожидания при синхронизации потоков?
- Почему проверку условия при ожидании на `condition_variable` необходимо выполнять в цикле?
- Как происходит взаимодействие между `mutex`, `condition_variable` и предикатом при ожидании события?
- Опишите паттерн «продюсер–потребитель» с использованием `condition_variable`.
- Как реализуется потокобезопасный стек с методом `wait_and_pop`? Какие меры предосторожности нужно учитывать?
- Что такое spurious wakeup и как избежать его негативного влияния?
- В чём особенности примитива `std::latch` и для каких сценариев его стоит использовать?
- Опишите, как можно синхронизировать завершение работы нескольких потоков с помощью `std::latch` (пример с эльфами).
- В чём различие между `std::latch` и `std::barrier` по функциональности и области применения?
- Как работает `std::barrier` и какую роль играет функция `on_completion`?
- Назовите типичные ошибки при работе с `std::barrier` и их последствия.
- Для чего используются `std::stop_source` и `std::stop_token`, и как они обеспечивают безопасную остановку потоков?
- Объясните, как работает `std::stop_callback`.
- В чём заключаются особенности работы `std::async` и какие возможны подводные камни при использовании `future::get()`?

## Lock-free

- Какими свойствами должна обладать структура данных или алгоритм,
  чтобы считаться lock-free?
- Какие гарантии исполнения могут предоставлять неблокирующие структуры данных и алгоритмы?

## Корутины

- Общие принципы работы корутин
  - Чем отличается корутина от обычной функции с точки зрения вызывающего её кода?
  - Когда и как создаётся объект, возвращаемый из корутины?
  - Что создаётся раньше — promise_type или возвращаемое значение корутины?
  - Можно ли определить promise_type вне возвращаемого типа (return object)? Если да, то как это делается? Если нет — почему?
  - Какую роль в работе корутины играет ReturnObject::promise_type?
- Поведение корутины и управление выполнением
  - Что должно произойти внутри корутины, чтобы у объекта-промиса был вызван final_suspend?
  - За счёт чего корутина-генератор возобновляет выполнение после co_yield?
  - Что нужно сделать, чтобы вручную возобновить выполнение приостановленной корутины?
  - Как сделать генератор, который бы не хранил копию значения, передаваемого через co_yield?
- Копирование, исключения и жизненный цикл
  - Что происходит с копированием и присваиванием возвращаемого типа корутины? Какие ограничения или тонкости существуют?
  - Как сохранить исключение, выброшенное внутри корутины, чтобы позже его можно было перехватить и обработать?
- Awaiter и co_await
  - Что такое awaiter и какие требования предъявляются к типу, чтобы он мог быть awaiter-ом?
  - Что возвращает оператор co_await?
  - Какие из методов awaiter-а должны быть noexcept и почему?
  - Какие типы может возвращать метод awaiter::await_suspend? Что означает каждый из них?
  - Что нужно сделать, чтобы co_await не приостанавливал выполнение корутины, а сразу продолжал его?
  - Как сделать так, чтобы возвращаемое значение корутины можно было ожидать с помощью co_await?
    Как при этом скрыть служебные методы от клиента?
- Работа с coroutine_handle
  - Чем отличается coroutine_handle<> от coroutine_handle<promise_type>?
  - Какой хендл передаётся в await_suspend? Что с ним можно делать внутри этого метода?
- Использование yield_value
  - Какой awaiter должен возвращаться из yield_value: suspend_always, suspend_never или другой тип? Чем определяется выбор?
