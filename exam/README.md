# Вопросы к экзамену/зачёту

- [Вопросы к экзамену/зачёту](#вопросы-к-экзаменузачёту)
  - [Конкурентность и параллелизм](#конкурентность-и-параллелизм)
  - [Подходы к конкурентности](#подходы-к-конкурентности)
  - [Конкурентность для разделения ответственности](#конкурентность-для-разделения-ответственности)
  - [Конкурентность для повышения производительности](#конкурентность-для-повышения-производительности)
  - [Lock-free](#lock-free)
  - [Корутины](#корутины)

## Конкурентность и параллелизм

- Что такое конкурентность в компьютерных системах?
  Приведите примеры её применения из повседневной жизни или программного обеспечения.
- В чём заключается ключевое отличие параллелизма от конкурентности?
  Объясните, как они различаются по целям и подходам.
- Перечислите основные предпосылки использования конкурентности в программировании.
- Какие аппаратные требования необходимы для реализации параллелизма?
  Почему конкурентность может обходиться без них?
- Объясните, как конкурентность улучшает отзывчивость пользовательского интерфейса.
- Какие цели преследует параллелизм?
- В чём состоит идея "переключения между задачами" в конкурентности?
  Как это отличается от "одновременного выполнения" в параллелизме?
- Приведите пример ситуации, где конкурентность будет более эффективной, чем параллелизм. Почему?
- Как конкурентность и параллелизм взаимодействуют в приложениях, например в играх.
- Почему для высоконагруженных серверных систем важна реализация конкурентности?
  Как это влияет на производительность?

## Подходы к конкурентности

- Проиллюстрируйте разницу между многопроцессностью и многопоточностью на примере организации совместной работы в реальной жизни?
  Какие преимущества и недостатки каждого подхода можно выделить?
- В чём заключаются основные отличия многопроцессного подхода от многопоточного?
  Приведите примеры сценариев, где каждый из подходов будет предпочтительным.
- Перечислите механизмы межпроцессного взаимодействия (IPC).
  Какие из них являются наиболее эффективными для передачи больших объёмов данных?
- Почему управление потоками требует меньше ресурсов по сравнению с процессами?
  Какие риски возникают при использовании общей памяти в многопоточном приложении?
- Что такое SIMD-инструкции? Как они используются для повышения производительности вычислений?
  Приведите примеры реализации SIMD на различных архитектурах процессоров.
  Назовите особенности этих реализаций.
- В чём заключается автоматическая векторизация компилятором,
  как она отличается от использования инструкций intrinsic или ассемблера?
  Когда какой способ векторизации использовать?
- Какова архитектура GPU, и в чём её отличие от архитектуры CPU?
  Почему GPU подходит для задач с массовым параллелизмом?
- Объясните концепцию SIMT (Single Instruction – Multiple Threads) в контексте работы GPU.
  Как это влияет на выполнение параллельных вычислений?
- В каких сценариях целесообразно использовать комбинацию многопроцессного и многопоточного подходов?
  Приведите примеры из реальных систем.
- Сравните подходы к конкурентности: многопроцессность, многопоточность, векторизация и вычисления на GPU.
  В каких задачах каждый из них будет наиболее эффективен?
  Приведите примеры использования для каждого подхода.

## Конкурентность для разделения ответственности

- Как конкурентность помогает в разделении ответственности между разнородными задачами в программе?
  Приведите пример, где это особенно важно.
- Почему UI-поток должен быть отделен от фоновых операций?
  Как это обеспечивает иллюзию отзывчивости интерфейса?
- Объясните, почему количество потоков в конкурентном приложении может превышать количество ядер процессора.
  Как операционная система управляет такими потоками?
- Как разделение кода на связанный и несвязанный влияет на структуру программы?
  В чем преимущества такого подхода?
- Почему в примере многопоточного видеоплеера используется отдельный поток для декодирования видео и аудио?
  Как это улучшает производительность?
- Как потоки, выполняющие ввод-вывод (например, чтение с диска или сети), вносят вклад в общую эффективность приложения?
  Почему их можно считать "простаивающими"?
- Как использование конкурентности упрощает ручное переключение задач в программе?
  Приведите сценарий, где это особенно актуально.
- Почему в многопоточном видеоплеере потоки могут работать даже на однопроцессорном компьютере?
  Как это связано с работой планировщика ОС?
- Как разделение ответственности между потоками влияет на надежность и поддержку программы?
  Приведите пример, где это проявляется.
- Объясните, как конкурентность позволяет одновременно обрабатывать ввод пользователя,
  декодировать медиаданные и обновлять интерфейс в видеоплеере. Почему такой подход эффективен?

## Конкурентность для повышения производительности

- Как закон Мура связан с переходом от повышения тактовой частоты к параллельным вычислениям?
  Почему это важно для программистов?
- Почему стоимость разработки чипов (по закону Рока) стала критическим фактором в развитии процессоров?
  Как это повлияло на подходы к повышению производительности?
- Объясните, почему современные процессоры перестали увеличивать тактовую частоту и начали использовать многоядерные архитектуры.
  Как это связано с физическими ограничениями?
  Как физический предел роста количества транзисторов влияет на дальнейшее развитие производительности процессоров?
  Почему теперь фокус на параллельных вычислениях?
- Почему однопоточная программа не может воспользоваться преимуществами многоядерных процессоров?
  Приведите пример, где это приведёт к снижению производительности.
- Почему программное обеспечение должно быть адаптировано для работы с многоядерными системами?
  Какие последствия возникают, если это игнорировать?
- Как закон Мура и физические ограничения (например, размеры атома) повлияли на развитие архитектуры процессоров?
  Почему параллелизм стал ключевым направлением в последнее время?
- Объясните, как использование конкурентности позволяет приложениям эффективно использовать
  ресурсы современных многопроцессорных систем.
  Приведите пример сценария, где это критично.
- Почему GPU и мобильные устройства требуют от программ поддержки параллелизма?
  Как это связано с их архитектурными особенностями?
- Как современные системы (домашние компьютеры, мобильные устройства) демонстрируют необходимость параллельных вычислений?
  Почему однопоточная модель больше не подходит?

## Lock-free

- Какими свойствами должна обладать структура данных или алгоритм,
  чтобы считаться lock-free?
- Какие гарантии исполнения могут предоставлять неблокирующие структуры данных и алгоритмы?
- 

## Корутины

- Когда и как создаётся возвращаемый из корутины объект?
- Что должно произойти внутри корутины, чтобы у промиса вызвался final_suspend.- Чем отличается coroutine_handle<> от coroutine_handle<promise>?
- Что раньше создаётся promise_type или возвращаемое значение?
- Что насчёт копирования и присваивания возвращаемого типа корутины?
- Чем отличается корутина от обычной функции с точки зрения вызывающего её кода?
- Можно ли разместить определение promise_type вне return object? Если да, то как, если нет, то почему?
- Какой awaiter должен возвращать yield_value: suspend_always или suspend_never, почему? Может ли возвращать другой тип awaiter.
- За счёт чего корутина-генератор возобновляет выполнение после вызова co_yield?
- Что нужно сделать, чтобы возобновить работу приостановленной корутины?
- Как сделать генератор, который бы не хранил копию yielded значения?
- Какие типы возвращаемых значений могут быть у метода awaiter::await_suspend.
  Что они означают?
- Что нужно сделать у возвращаемого значения корутины, чтобы его можно было
  ожидать с помощью операции co_await? Как сделать так, чтобы особые методы не были видны клиентам напрямую?
- Какую роль в работе корутины играет ReturnObject::promise_type?
- Как сохранить исключение, выброшенное в теле корутины, чтобы потом можно было узнать о его наличии и выбросить?
- Что такое awaiter? Что нужно сделать, чтобы тип мог быть awaiter-ом?
- Что нужно сделать, чтобы co_await не приостанавливал выполнение корутины на awaiter-е, а сразу продолжал ее работу?
- Что возвращает оператор co_await?
- Какие из методов awaiter-а должны быть noexcept и почему?
- Хендл какой корутины передаётся в await_suspend?
- Что с ним можно сделать внутри await_suspend?
