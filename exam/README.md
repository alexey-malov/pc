# Вопросы к экзамену/зачёту

- [Вопросы к экзамену/зачёту](#вопросы-к-экзаменузачёту)
  - [Конкурентность и параллелизм](#конкурентность-и-параллелизм)
    - [Общие сведения о конкурентности и параллелизме](#общие-сведения-о-конкурентности-и-параллелизме)
    - [Подходы к конкурентности](#подходы-к-конкурентности)
    - [Конкурентность для разделения ответственности](#конкурентность-для-разделения-ответственности)
    - [Конкурентность для повышения производительности](#конкурентность-для-повышения-производительности)
    - [Чрезвычайная параллельность](#чрезвычайная-параллельность)
    - [Когда использовать, а когда не использовать конкурентность](#когда-использовать-а-когда-не-использовать-конкурентность)
  - [Закон Амдала](#закон-амдала)
  - [Lock-free](#lock-free)
  - [Корутины](#корутины)

## Конкурентность и параллелизм

### Общие сведения о конкурентности и параллелизме

- Что такое конкурентность в компьютерных системах?
  Приведите примеры её применения из повседневной жизни или программного обеспечения.
- В чём заключается ключевое отличие параллелизма от конкурентности?
  Объясните, как они различаются по целям и подходам.
- Перечислите основные предпосылки использования конкурентности в программировании.
- Какие аппаратные требования необходимы для реализации параллелизма?
  Почему конкурентность может обходиться без них?
- Объясните, как конкурентность улучшает отзывчивость пользовательского интерфейса.
- Какие цели преследует параллелизм?
- В чём состоит идея "переключения между задачами" в конкурентности?
  Как это отличается от "одновременного выполнения" в параллелизме?
- Приведите пример ситуации, где конкурентность будет более эффективной, чем параллелизм. Почему?
- Как конкурентность и параллелизм взаимодействуют в приложениях, например в играх.
- Почему для высоконагруженных серверных систем важна реализация конкурентности?
  Как это влияет на производительность?

### Подходы к конкурентности

- Проиллюстрируйте разницу между многопроцессностью и многопоточностью на примере организации совместной работы в реальной жизни?
  Какие преимущества и недостатки каждого подхода можно выделить?
- В чём заключаются основные отличия многопроцессного подхода от многопоточного?
  Приведите примеры сценариев, где каждый из подходов будет предпочтительным.
- Перечислите механизмы межпроцессного взаимодействия (IPC).
  Какие из них являются наиболее эффективными для передачи больших объёмов данных?
- Почему управление потоками требует меньше ресурсов по сравнению с процессами?
  Какие риски возникают при использовании общей памяти в многопоточном приложении?
- Что такое SIMD-инструкции? Как они используются для повышения производительности вычислений?
  Приведите примеры реализации SIMD на различных архитектурах процессоров.
  Назовите особенности этих реализаций.
- В чём заключается автоматическая векторизация компилятором,
  как она отличается от использования инструкций intrinsic или ассемблера?
  Когда какой способ векторизации использовать?
- Какова архитектура GPU, и в чём её отличие от архитектуры CPU?
  Почему GPU подходит для задач с массовым параллелизмом?
- Объясните концепцию SIMT (Single Instruction – Multiple Threads) в контексте работы GPU.
  Как это влияет на выполнение параллельных вычислений?
- В каких сценариях целесообразно использовать комбинацию многопроцессного и многопоточного подходов?
  Приведите примеры из реальных систем.
- Сравните подходы к конкурентности: многопроцессность, многопоточность, векторизация и вычисления на GPU.
  В каких задачах каждый из них будет наиболее эффективен?
  Приведите примеры использования для каждого подхода.

### Конкурентность для разделения ответственности

- Как конкурентность помогает в разделении ответственности между разнородными задачами в программе?
  Приведите пример, где это особенно важно.
- Почему UI-поток должен быть отделен от фоновых операций?
  Как это обеспечивает иллюзию отзывчивости интерфейса?
- Объясните, почему количество потоков в конкурентном приложении может превышать количество ядер процессора.
  Как операционная система управляет такими потоками?
- Как разделение кода на связанный и несвязанный влияет на структуру программы?
  В чем преимущества такого подхода?
- Почему в примере многопоточного видеоплеера используется отдельный поток для декодирования видео и аудио?
  Как это улучшает производительность?
- Как потоки, выполняющие ввод-вывод (например, чтение с диска или сети), вносят вклад в общую эффективность приложения?
  Почему их можно считать "простаивающими"?
- Как использование конкурентности упрощает ручное переключение задач в программе?
  Приведите сценарий, где это особенно актуально.
- Почему в многопоточном видеоплеере потоки могут работать даже на однопроцессорном компьютере?
  Как это связано с работой планировщика ОС?
- Как разделение ответственности между потоками влияет на надежность и поддержку программы?
  Приведите пример, где это проявляется.
- Объясните, как конкурентность позволяет одновременно обрабатывать ввод пользователя,
  декодировать медиаданные и обновлять интерфейс в видеоплеере. Почему такой подход эффективен?

### Конкурентность для повышения производительности

- Как закон Мура связан с переходом от повышения тактовой частоты к параллельным вычислениям?
  Почему это важно для программистов?
- Почему стоимость разработки чипов (по закону Рока) стала критическим фактором в развитии процессоров?
  Как это повлияло на подходы к повышению производительности?
- Объясните, почему современные процессоры перестали увеличивать тактовую частоту и начали использовать многоядерные архитектуры.
  Как это связано с физическими ограничениями?
  Как физический предел роста количества транзисторов влияет на дальнейшее развитие производительности процессоров?
  Почему теперь фокус на параллельных вычислениях?
- Почему однопоточная программа не может воспользоваться преимуществами многоядерных процессоров?
  Приведите пример, где это приведёт к снижению производительности.
- Почему программное обеспечение должно быть адаптировано для работы с многоядерными системами?
  Какие последствия возникают, если это игнорировать?
- Как закон Мура и физические ограничения (например, размеры атома) повлияли на развитие архитектуры процессоров?
  Почему параллелизм стал ключевым направлением в последнее время?
- Объясните, как использование конкурентности позволяет приложениям эффективно использовать
  ресурсы современных многопроцессорных систем.
  Приведите пример сценария, где это критично.
- Почему GPU и мобильные устройства требуют от программ поддержки параллелизма?
  Как это связано с их архитектурными особенностями?
- Как современные системы (домашние компьютеры, мобильные устройства) демонстрируют необходимость параллельных вычислений?
  Почему однопоточная модель больше не подходит?

### Чрезвычайная параллельность

- Объясните, какие алгоритмы или задачи называются "чрезвычайно параллельными"
  и почему они отличаются от других по характеру взаимодействия между параллельными потоками?
  Приведите примеры из слайда.
- Почему задачи, такие как рендеринг 3D-графики или майнинг криптовалюты, являются особенно подходящими для параллельного исполнения?
  Какие архитектурные особенности оборудования способствуют этому?
- Как факторы производительности, такие как скорость диска или процессора, влияют на эффективность параллелизации задач,
  например, при отдаче статических файлов с веб-сервера? Объясните на примере.
- Опишите, как можно распараллелить вычисления в системе моделирования частиц
  (например, с использованием физических законов взаимодействия).
  Как такое разделение обеспечивает прирост производительности?

### Когда использовать, а когда не использовать конкурентность

- Перечислите основные причины, по которым использование конкурентности может быть нецелесообразным.
  Объясните, как сложность кода и затраты на отладку влияют на это решение.
- Почему создание большого количества потоков в 32-битных системах ограничено? Какие ресурсы исчерпываются в этом случае?
- Как накладные расходы на создание потоков могут превысить выигрыш в производительности?
  В каких сценариях это особенно актуально?
  Объясните, как переключение контекста между потоками влияет на производительность системы.
- Почему для обслуживания большого количества соединений в веб-сервере не подходит подход "один поток на соединение"?
  Какие есть альтернативы этому подходу?
- В чём преимущество пула потоков перед созданием отдельного потока для каждой задачи?
- Как асинхронный ввод-вывод уменьшает накладные расходы на переключение контекста?
- Объясните, как это реализуется в многопоточных приложениях.
- Почему в 64-битных системах ограничений на количество потоков меньше, чем в 32-битных?
  Какие ресурсы всё равно остаются ограничивающими?
- В чём разница между кооперативной многозадачностью и классическим многопоточным подходом?
  Как это влияет на производительность веб-сервера при обработке тысяч соединений?

## Закон Амдала

- Объясните суть закона Амдала и его формулу. Как она учитывает параллельную и последовательную части программы?
  Напишите формулу.
- Как максимальное ускорение программы ограничивается долями, которые нельзя распараллелить?
  Приведите примеры.
- Рассчитайте максимальное ускорение программы, если 20% времени занимает последовательная часть.
- Почему добавление большого количества процессоров не всегда приводит к линейному ускорению? С чем это связано?
- Как изменится формула Амдала, если учесть накладные расходы на синхронизацию и координацию между потоками?
  Приведите модифицированную формулу.
- Решите задачи на использование закона Амдала, предложенные преподавателем.

## Lock-free

- Какими свойствами должна обладать структура данных или алгоритм,
  чтобы считаться lock-free?
- Какие гарантии исполнения могут предоставлять неблокирующие структуры данных и алгоритмы?

## Корутины

- Общие принципы работы корутин
  - Чем отличается корутина от обычной функции с точки зрения вызывающего её кода?
  - Когда и как создаётся объект, возвращаемый из корутины?
  - Что создаётся раньше — promise_type или возвращаемое значение корутины?
  - Можно ли определить promise_type вне возвращаемого типа (return object)? Если да, то как это делается? Если нет — почему?
  - Какую роль в работе корутины играет ReturnObject::promise_type?
- Поведение корутины и управление выполнением
  - Что должно произойти внутри корутины, чтобы у объекта-промиса был вызван final_suspend?
  - За счёт чего корутина-генератор возобновляет выполнение после co_yield?
  - Что нужно сделать, чтобы вручную возобновить выполнение приостановленной корутины?
  - Как сделать генератор, который бы не хранил копию значения, передаваемого через co_yield?
- Копирование, исключения и жизненный цикл
  - Что происходит с копированием и присваиванием возвращаемого типа корутины? Какие ограничения или тонкости существуют?
  - Как сохранить исключение, выброшенное внутри корутины, чтобы позже его можно было перехватить и обработать?
- Awaiter и co_await
  - Что такое awaiter и какие требования предъявляются к типу, чтобы он мог быть awaiter-ом?
  - Что возвращает оператор co_await?
  - Какие из методов awaiter-а должны быть noexcept и почему?
  - Какие типы может возвращать метод awaiter::await_suspend? Что означает каждый из них?
  - Что нужно сделать, чтобы co_await не приостанавливал выполнение корутины, а сразу продолжал его?
  - Как сделать так, чтобы возвращаемое значение корутины можно было ожидать с помощью co_await?
    Как при этом скрыть служебные методы от клиента?
- Работа с coroutine_handle
  - Чем отличается coroutine_handle<> от coroutine_handle<promise_type>?
  - Какой хендл передаётся в await_suspend? Что с ним можно делать внутри этого метода?
- Использование yield_value
  - Какой awaiter должен возвращаться из yield_value: suspend_always, suspend_never или другой тип? Чем определяется выбор?
